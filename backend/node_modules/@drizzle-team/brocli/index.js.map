{"version":3,"sources":["../node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js","../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/quote.js","../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/parse.js","../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/index.js","../src/brocli-error.ts","../src/command-core.ts","../src/help-themes.ts","../src/util.ts","../src/option-builder.ts"],"sourcesContent":["var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","'use strict';\n\nmodule.exports = function quote(xs) {\n\treturn xs.map(function (s) {\n\t\tif (s && typeof s === 'object') {\n\t\t\treturn s.op.replace(/(.)/g, '\\\\$1');\n\t\t}\n\t\tif ((/[\"\\s]/).test(s) && !(/'/).test(s)) {\n\t\t\treturn \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n\t\t}\n\t\tif ((/[\"'\\s]/).test(s)) {\n\t\t\treturn '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t\t}\n\t\treturn String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@[\\\\\\]^`{|}])/g, '$1\\\\$2');\n\t}).join(' ');\n};\n","'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|',\n\t'\\\\&\\\\&',\n\t';;',\n\t'\\\\|\\\\&',\n\t'\\\\<\\\\(',\n\t'\\\\<\\\\<\\\\<',\n\t'>>',\n\t'>\\\\&',\n\t'<\\\\&',\n\t'[&;()|<>]'\n].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\n\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\n\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\n\nfunction matchAll(s, r) {\n\tvar origIndex = r.lastIndex;\n\n\tvar matches = [];\n\tvar matchObj;\n\n\twhile ((matchObj = r.exec(s))) {\n\t\tmatches.push(matchObj);\n\t\tif (r.lastIndex === matchObj.index) {\n\t\t\tr.lastIndex += 1;\n\t\t}\n\t}\n\n\tr.lastIndex = origIndex;\n\n\treturn matches;\n}\n\nfunction getVar(env, pre, key) {\n\tvar r = typeof env === 'function' ? env(key) : env[key];\n\tif (typeof r === 'undefined' && key != '') {\n\t\tr = '';\n\t} else if (typeof r === 'undefined') {\n\t\tr = '$';\n\t}\n\n\tif (typeof r === 'object') {\n\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t}\n\treturn pre + r;\n}\n\nfunction parseInternal(string, env, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tvar BS = opts.escape || '\\\\';\n\tvar BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'\n\t].join('|'), 'g');\n\n\tvar matches = matchAll(string, chunker);\n\n\tif (matches.length === 0) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\n\tvar commented = false;\n\n\treturn matches.map(function (match) {\n\t\tvar s = match[0];\n\t\tif (!s || commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (controlRE.test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\tvar char = s.charAt(i);\n\n\t\t\tif (char === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.slice(i, varend);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(char)) {\n\t\t\t\tvarname = char;\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar slicedFromI = s.slice(i);\n\t\t\t\tvarend = slicedFromI.match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = slicedFromI;\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = slicedFromI.slice(0, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(env, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (controlRE.test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if (hash.test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tvar commentObj = { comment: string.slice(match.index + i + 1) };\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, commentObj];\n\t\t\t\t}\n\t\t\t\treturn [commentObj];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed arguments\n\t\t// TODO: replace this whole reduce with a concat\n\t\treturn typeof arg === 'undefined' ? prev : prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (startsWithToken.test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","/**\n * Internal error class used to bypass runCli's logging without stack trace\n *\n * Used only for malformed commands and options\n */\nexport class BroCliError extends Error {\n\tconstructor(message: string | undefined) {\n\t\tconst errPrefix = 'BroCli error: ';\n\t\tsuper(message === undefined ? message : `${errPrefix}${message}`);\n\t}\n}\n","import clone from 'clone';\nimport { parse as parseQuotes } from 'shell-quote';\nimport { BroCliError } from './brocli-error';\nimport { defaultTheme } from './help-themes';\nimport {\n\ttype GenericBuilderInternals,\n\ttype GenericBuilderInternalsFields,\n\ttype OutputType,\n\ttype ProcessedBuilderConfig,\n\ttype ProcessedOptions,\n\ttype TypeOf,\n} from './option-builder';\nimport { isInt } from './util';\n\n// Type area\nexport type HelpHandler = (calledFor: Command | Command[]) => any;\n\nexport type CommandHandler<\n\tTOpts extends Record<string, GenericBuilderInternals> | undefined =\n\t\t| Record<string, GenericBuilderInternals>\n\t\t| undefined,\n> = (\n\toptions: TOpts extends Record<string, GenericBuilderInternals> ? TypeOf<TOpts> : undefined,\n) => any;\n\nexport type CommandInfo = {\n\tname: string;\n\taliases?: [string, ...string[]];\n\tdescription?: string;\n\thidden?: boolean;\n\toptions?: Record<string, ProcessedBuilderConfig>;\n\tmetaInfo?: string;\n\tsubcommands?: CommandsInfo;\n};\n\nexport type CommandsInfo = Record<string, CommandInfo>;\n\nexport type EventType = 'pre' | 'post';\n\nexport type BroCliConfig = {\n\targSource?: string[];\n\thelp?: HelpHandler;\n\tversion?: string | Function;\n\tomitKeysOfUndefinedOptions?: boolean;\n\thook?: (event: EventType, command: Command) => any;\n};\n\nexport type GenericCommandHandler = (options?: Record<string, OutputType> | undefined) => any;\n\nexport type RawCommand<\n\tTOpts extends Record<string, GenericBuilderInternals> | undefined =\n\t\t| Record<string, GenericBuilderInternals>\n\t\t| undefined,\n\tTOptsData = TOpts extends Record<string, GenericBuilderInternals> ? TypeOf<TOpts> : undefined,\n\tTTransformed = TOptsData extends undefined ? undefined : TOptsData,\n> = {\n\tname?: string;\n\taliases?: [string, ...string[]];\n\tdescription?: string;\n\thidden?: boolean;\n\toptions?: TOpts;\n\thelp?: string | Function;\n\ttransform?: (options: TOptsData) => TTransformed;\n\thandler?: (options: Awaited<TTransformed>) => any;\n\tsubcommands?: [Command, ...Command[]];\n\tmetaInfo?: string;\n};\n\nexport type AnyRawCommand<\n\tTOpts extends Record<string, GenericBuilderInternals> | undefined =\n\t\t| Record<string, GenericBuilderInternals>\n\t\t| undefined,\n> = {\n\tname?: string;\n\taliases?: [string, ...string[]];\n\tdescription?: string;\n\thidden?: boolean;\n\toptions?: TOpts;\n\thelp?: string | Function;\n\ttransform?: GenericCommandHandler;\n\thandler?: GenericCommandHandler;\n\tsubcommands?: [Command, ...Command[]];\n\tmetaInfo?: string;\n};\n\nexport type Command<TOptsType = any, TTransformedType = any> = {\n\tname: string;\n\taliases?: [string, ...string[]];\n\tdescription?: string;\n\thidden?: boolean;\n\toptions?: ProcessedOptions;\n\thelp?: string | Function;\n\ttransform?: GenericCommandHandler;\n\thandler: GenericCommandHandler;\n\tsubcommands?: [Command, ...Command[]];\n\tparent?: Command;\n\tmetaInfo?: string;\n};\n\nexport type CommandCandidate = {\n\tdata: string;\n\toriginalIndex: number;\n};\n\nexport type InnerCommandParseRes = {\n\tcommand: Command | undefined;\n\targs: string[];\n};\n\nexport type TestResult<THandlerInput> = {\n\ttype: 'handler';\n\toptions: THandlerInput;\n} | {\n\ttype: 'help' | 'version';\n} | {\n\ttype: 'error';\n\terror: unknown;\n};\n\n// Message area\nconst unknownCommand = (caller: string) => {\n\tconst msg = `Unknown command: '${caller}'.\\nType '--help' to get help on the cli.`;\n\n\treturn new Error(msg);\n};\n\nconst unknownSubcommand = (command: Command, caller: string) => {\n\tconst name = getCommandNameRecursive(command);\n\n\tconst msg = `Unknown command: ${name} ${caller}.\\nType '${name} --help' to get the help on command.`;\n\tnew Error(\n\t\tmsg,\n\t);\n\n\treturn new Error(msg);\n};\n\nconst missingRequired = (command: RawCommand<any, any, any>, missingOpts: [string[], ...string[][]]) => {\n\tconst msg = `Command '${command.name}' is missing following required options: ${\n\t\tmissingOpts.map((opt) => {\n\t\t\tconst name = opt.shift()!;\n\t\t\tconst aliases = opt;\n\n\t\t\tif (aliases.length) return `${name} [${aliases.join(', ')}]`;\n\n\t\t\treturn name;\n\t\t}).join(', ')\n\t}`;\n\n\treturn new Error(msg);\n};\n\nconst unrecognizedOptions = (command: RawCommand<any, any, any>, unrecognizedArgs: [string, ...string[]]) => {\n\tconst msg = `Unrecognized options for command '${command.name}': ${unrecognizedArgs.join(', ')}`;\n\n\treturn new Error(msg);\n};\n\nconst invalidBooleanSyntax = (matchedName: string) => {\n\treturn new Error(\n\t\t`Invalid syntax: boolean type argument '${matchedName}' must have it's value passed in the following formats: ${matchedName}=<value> | ${matchedName} <value> | ${matchedName}.\\nAllowed values: true, false, 0, 1`,\n\t);\n};\n\nconst invalidStringSyntax = (matchedName: string) => {\n\treturn new Error(\n\t\t`Invalid syntax: string type argument '${matchedName}' must have it's value passed in the following formats: ${matchedName}=<value> | ${matchedName} <value>`,\n\t);\n};\n\nconst enumViolation = (matchedName: string, data: string | undefined, values: [string, ...string[]]) => {\n\treturn new Error(\n\t\t`Invalid value: value for the argument '${matchedName}' must be either one of the following: ${\n\t\t\tvalues.join(', ')\n\t\t}; Received: ${data}`,\n\t);\n};\n\nconst enumViolationPos = (matchedName: string, data: string | undefined, values: [string, ...string[]]) => {\n\treturn new Error(\n\t\t`Invalid value: value for the argument '${matchedName}' must be either one of the following: ${\n\t\t\tvalues.join(', ')\n\t\t}; Received: ${data}`,\n\t);\n};\n\nconst invalidNumberSyntax = (matchedName: string) => {\n\treturn new Error(\n\t\t`Invalid syntax: number type argument '${matchedName}' must have it's value passed in the following formats: ${matchedName}=<value> | ${matchedName} <value>`,\n\t);\n};\n\nconst invalidNumberValue = (matchedName: string, data: string | undefined) => {\n\treturn new Error(\n\t\t`Invalid value: number type argument '${matchedName}' expects a number as an input, got: ${data}`,\n\t);\n};\n\nconst invalidInteger = (matchedName: string, data: string | undefined) => {\n\treturn new Error(\n\t\t`Invalid value: number type argument '${matchedName}' expects an integer as an input, got: ${data}`,\n\t);\n};\n\nconst belowMin = (matchedName: string, data: string | undefined, min: number) => {\n\treturn new Error(\n\t\t`Invalid value: number type argument '${matchedName}' expects minimal value of ${min} as an input, got: ${data}`,\n\t);\n};\n\nconst aboveMax = (matchedName: string, data: string | undefined, max: number) => {\n\treturn new Error(\n\t\t`Invalid value: number type argument '${matchedName}' expects maximal value of ${max} as an input, got: ${data}`,\n\t);\n};\n\n// Main area\nconst generatePrefix = (name: string) => name.startsWith('-') ? name : name.length > 1 ? `--${name}` : `-${name}`;\n\nconst validateOptions = <TOptionConfig extends Record<string, GenericBuilderInternals>>(\n\tconfig: TOptionConfig,\n): ProcessedOptions<TOptionConfig> => {\n\tconst cloned = clone(config);\n\n\tconst entries: [string, GenericBuilderInternalsFields][] = [];\n\n\tconst storedNames: Record<string, [string, ...string[]]> = {};\n\n\tconst cfgEntries = Object.entries(cloned);\n\n\tfor (const [key, value] of cfgEntries) {\n\t\tconst cfg = value._.config;\n\n\t\tif (cfg.name === undefined) cfg.name = key;\n\n\t\tif (cfg.type === 'positional') continue;\n\n\t\tif (cfg.name!.includes('=')) {\n\t\t\tthrow new BroCliError(\n\t\t\t\t`Can't define option ${cfg.name} - option names and aliases cannot contain '='!`,\n\t\t\t);\n\t\t}\n\n\t\tfor (const alias of cfg.aliases) {\n\t\t\tif (alias.includes('=')) {\n\t\t\t\tthrow new BroCliError(\n\t\t\t\t\t`Can't define option ${cfg.name} - option names and aliases cannot contain '='!`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tcfg.name = generatePrefix(cfg.name);\n\n\t\tcfg.aliases = cfg.aliases.map((a) => generatePrefix(a));\n\t}\n\n\tfor (const [key, value] of cfgEntries) {\n\t\tconst cfg = value._.config;\n\n\t\tif (cfg.type === 'positional') {\n\t\t\tentries.push([key, { config: cfg, $output: undefined as any }]);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst reservedNames = ['--help', '-h', '--version', '-v'];\n\n\t\tconst allNames = [cfg.name, ...cfg.aliases];\n\n\t\tfor (const name of allNames) {\n\t\t\tconst match = reservedNames.find((n) => n === name);\n\t\t\tif (match) throw new BroCliError(`Can't define option ${cfg.name} - name '${match}' is reserved!`);\n\t\t}\n\n\t\tconst storageVals = Object.values(storedNames);\n\n\t\tfor (const storage of storageVals) {\n\t\t\tconst nameOccupier = storage.find((e) => e === cfg.name);\n\n\t\t\tif (!nameOccupier) continue;\n\n\t\t\tthrow new BroCliError(\n\t\t\t\t`Can't define option '${cfg.name}': name is already in use by option '${storage[0]}'!`,\n\t\t\t);\n\t\t}\n\n\t\tfor (const alias of cfg.aliases) {\n\t\t\tfor (const storage of storageVals) {\n\t\t\t\tconst nameOccupier = storage.find((e) => e === alias);\n\n\t\t\t\tif (!nameOccupier) continue;\n\n\t\t\t\tthrow new BroCliError(\n\t\t\t\t\t`Can't define option '${cfg.name}': alias '${alias}' is already in use by option '${storage[0]}'!`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tstoredNames[cfg.name!] = [cfg.name!, ...cfg.aliases];\n\n\t\tstoredNames[cfg.name!]!.forEach((name, idx) => {\n\t\t\tif (storedNames[cfg.name!]!.findIndex((e) => e === name) === idx) return;\n\n\t\t\tthrow new BroCliError(\n\t\t\t\t`Can't define option '${cfg.name}': duplicate aliases '${name}'!`,\n\t\t\t);\n\t\t});\n\n\t\tentries.push([key, { config: cfg, $output: undefined as any }]);\n\t}\n\n\treturn Object.fromEntries(entries) as ProcessedOptions<any>;\n};\n\nconst assignParent = (parent: Command, subcommands: Command[]) =>\n\tsubcommands.forEach((e) => {\n\t\te.parent = parent;\n\t\tif (e.subcommands) assignParent(e, e.subcommands);\n\t});\n\nexport const command = <\n\tTOpts extends Record<string, GenericBuilderInternals> | undefined,\n\tTOptsData = TOpts extends Record<string, GenericBuilderInternals> ? TypeOf<TOpts> : undefined,\n\tTTransformed = TOptsData,\n>(command: RawCommand<TOpts, TOptsData, TTransformed>): Command<TOptsData, Awaited<TTransformed>> => {\n\tconst allNames = command.aliases ? [command.name, ...command.aliases] : [command.name];\n\n\tconst cmd: Command = clone(command) as any;\n\tif (\n\t\t(<AnyRawCommand> command).subcommands && command.options\n\t\t&& Object.values(command.options).find((opt) => opt._.config.type === 'positional')\n\t) {\n\t\tthrow new BroCliError(\n\t\t\t`Can't define command '${cmd.name}' - command can't have subcommands and positional args at the same time!`,\n\t\t);\n\t}\n\n\tconst processedOptions = command.options ? validateOptions(command.options) : undefined;\n\tcmd.options = processedOptions;\n\n\tcmd.name = cmd.name ?? cmd.aliases?.shift();\n\n\tif (!cmd.name) throw new BroCliError(`Can't define command without name!`);\n\n\tcmd.aliases = cmd.aliases?.length ? cmd.aliases : undefined;\n\n\tif (!cmd.handler) throw new BroCliError(`Can't define command '${cmd.name}' - command must have a handler!`);\n\n\tif (cmd.name.startsWith('-')) {\n\t\tthrow new BroCliError(`Can't define command '${cmd.name}' - command name can't start with '-'!`);\n\t}\n\n\tcmd.aliases?.forEach((a) => {\n\t\tif (a.startsWith('-')) {\n\t\t\tthrow new BroCliError(`Can't define command '${cmd.name}' - command aliases can't start with '-'!`);\n\t\t}\n\t});\n\n\tallNames.forEach((n, i) => {\n\t\tif (n === 'help') {\n\t\t\tthrow new BroCliError(\n\t\t\t\t`Can't define command '${cmd.name}' - 'help' is a reserved name. If you want to redefine help message - do so in runCli's config.`,\n\t\t\t);\n\t\t}\n\n\t\tconst lCaseName = n?.toLowerCase();\n\t\tif (lCaseName === '0' || lCaseName === '1' || lCaseName === 'true' || lCaseName === 'false') {\n\t\t\tthrow new BroCliError(\n\t\t\t\t`Can't define command '${cmd.name}' - '${n}' is a reserved for boolean values name!`,\n\t\t\t);\n\t\t}\n\n\t\tconst idx = allNames.findIndex((an) => an === n);\n\n\t\tif (idx !== i) throw new BroCliError(`Can't define command '${cmd.name}' - duplicate alias '${n}'!`);\n\t});\n\n\tif (cmd.subcommands) {\n\t\tassignParent(cmd, cmd.subcommands);\n\t}\n\n\treturn cmd;\n};\n\nconst getCommandInner = (commands: Command[], candidates: CommandCandidate[], args: string[]): InnerCommandParseRes => {\n\tconst { data: arg, originalIndex: index } = candidates.shift()!;\n\n\tconst command = commands.find((c) => {\n\t\tconst names = c.aliases ? [c.name, ...c.aliases] : [c.name];\n\t\tconst res = names.find((name) => name === arg);\n\n\t\treturn res;\n\t});\n\n\tif (!command) {\n\t\treturn {\n\t\t\tcommand,\n\t\t\targs,\n\t\t};\n\t}\n\n\tconst newArgs = removeByIndex(args, index);\n\n\tif (!candidates.length || !command.subcommands) {\n\t\treturn {\n\t\t\tcommand,\n\t\t\targs: newArgs,\n\t\t};\n\t}\n\n\tconst newCandidates = candidates.map((c) => ({ data: c.data, originalIndex: c.originalIndex - 1 }));\n\n\tconst subcommand = getCommandInner(command.subcommands!, newCandidates, newArgs);\n\n\tif (!subcommand.command) throw unknownSubcommand(command, candidates[0]!.data);\n\n\treturn subcommand;\n};\n\nconst getCommand = (commands: Command[], args: string[]) => {\n\tconst candidates: CommandCandidate[] = [];\n\n\tfor (let i = 0; i < args.length; ++i) {\n\t\tconst arg = args[i]!;\n\t\tif (arg === '--help' || arg === '-h' || arg === '--version' || arg === '-v') {\n\t\t\tconst lCaseNext = args[i + 1]?.toLowerCase();\n\t\t\tif (lCaseNext === '0' || lCaseNext === '1' || lCaseNext === 'true' || lCaseNext === 'false') ++i;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (arg?.startsWith('-')) {\n\t\t\tif (!arg.includes('=')) ++i;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tcandidates.push({\n\t\t\tdata: arg,\n\t\t\toriginalIndex: i,\n\t\t});\n\t}\n\n\tif (!candidates.length) {\n\t\treturn {\n\t\t\tcommand: undefined,\n\t\t\targs,\n\t\t};\n\t}\n\n\tconst firstCandidate = candidates[0]!;\n\n\tif (firstCandidate.data === 'help') {\n\t\treturn {\n\t\t\tcommand: 'help' as const,\n\t\t\targs: removeByIndex(args, firstCandidate.originalIndex),\n\t\t};\n\t}\n\n\tconst { command, args: argsRes } = getCommandInner(commands, candidates, args);\n\n\tif (!command) throw unknownCommand(firstCandidate.data);\n\n\treturn {\n\t\tcommand,\n\t\targs: argsRes,\n\t};\n};\n\nconst parseArg = (\n\toptions: [string, ProcessedBuilderConfig][],\n\tpositionals: [string, ProcessedBuilderConfig][],\n\targ: string,\n\tnextArg: string | undefined,\n) => {\n\tlet data: OutputType = undefined;\n\n\tconst argSplit = arg.split('=');\n\tconst hasEq = arg.includes('=');\n\n\tconst namePart = argSplit.shift();\n\tconst dataPart = hasEq ? argSplit.join('=') : nextArg;\n\tlet skipNext = !hasEq;\n\n\tif (namePart === '--help' || namePart === '-h') {\n\t\treturn {\n\t\t\tisHelp: true,\n\t\t};\n\t}\n\n\tif (namePart === '--version' || namePart === '-v') {\n\t\treturn {\n\t\t\tisVersion: true,\n\t\t};\n\t}\n\n\tif (!arg.startsWith('-')) {\n\t\tif (!positionals.length) return {};\n\n\t\tconst pos = positionals.shift()!;\n\n\t\tif (pos[1].enumVals && !pos[1].enumVals.find((val) => val === dataPart)) {\n\t\t\tthrow enumViolationPos(pos[1].name!, arg, pos[1].enumVals);\n\t\t}\n\n\t\tdata = arg;\n\n\t\treturn {\n\t\t\tdata,\n\t\t\tskipNext: false,\n\t\t\tname: pos[0],\n\t\t\toption: pos[1],\n\t\t};\n\t}\n\n\tconst option = options.find(([optKey, opt]) => {\n\t\tconst names = [opt.name!, ...opt.aliases];\n\n\t\tif (opt.type === 'boolean') {\n\t\t\tconst match = names.find((name) => name === namePart);\n\t\t\tif (!match) return false;\n\n\t\t\tlet lcaseData = dataPart?.toLowerCase();\n\n\t\t\tif (!hasEq && nextArg?.startsWith('-')) {\n\t\t\t\tdata = true;\n\t\t\t\tskipNext = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (lcaseData === undefined || lcaseData === '' || lcaseData === 'true' || lcaseData === '1') {\n\t\t\t\tdata = true;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (lcaseData === 'false' || lcaseData === '0') {\n\t\t\t\tdata = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!hasEq) {\n\t\t\t\tdata = true;\n\t\t\t\tskipNext = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tthrow invalidBooleanSyntax(match);\n\t\t} else {\n\t\t\tconst match = names.find((name) => name === namePart);\n\n\t\t\tif (!match) return false;\n\n\t\t\tif (opt.type === 'string') {\n\t\t\t\tif (!hasEq && nextArg === undefined) throw invalidStringSyntax(match);\n\n\t\t\t\tif (opt.enumVals && !opt.enumVals.find((val) => val === dataPart)) {\n\t\t\t\t\tthrow enumViolation(match, dataPart, opt.enumVals);\n\t\t\t\t}\n\n\t\t\t\tdata = dataPart;\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!hasEq && nextArg === undefined) throw invalidNumberSyntax(match);\n\n\t\t\tconst numData = Number(dataPart);\n\n\t\t\tif (isNaN(numData)) throw invalidNumberValue(match, dataPart);\n\n\t\t\tif (opt.isInt && !isInt(numData)) throw invalidInteger(match, dataPart);\n\n\t\t\tif (opt.minVal !== undefined && numData < opt.minVal) throw belowMin(match, dataPart, opt.minVal);\n\n\t\t\tif (opt.maxVal !== undefined && numData > opt.maxVal) throw aboveMax(match, dataPart, opt.maxVal);\n\n\t\t\tdata = dataPart;\n\n\t\t\treturn true;\n\t\t}\n\t});\n\n\treturn {\n\t\tdata,\n\t\tskipNext,\n\t\tname: option?.[0],\n\t\toption: option?.[1],\n\t};\n};\n\nconst parseOptions = (\n\tcommand: Command,\n\targs: string[],\n\tomitKeysOfUndefinedOptions?: boolean,\n): Record<string, OutputType> | 'help' | 'version' | undefined => {\n\tconst options = command.options;\n\n\tconst optEntries = Object.entries(options ?? {} as Exclude<typeof options, undefined>).map(\n\t\t(opt) => [opt[0], opt[1].config] as [string, ProcessedBuilderConfig],\n\t);\n\n\tconst nonPositionalEntries = optEntries.filter(([key, opt]) => opt.type !== 'positional');\n\tconst positionalEntries = optEntries.filter(([key, opt]) => opt.type === 'positional');\n\n\tconst result: Record<string, OutputType> = {};\n\n\tconst missingRequiredArr: string[][] = [];\n\tconst unrecognizedArgsArr: string[] = [];\n\n\tfor (let i = 0; i < args.length; ++i) {\n\t\tconst arg = args[i]!;\n\t\tconst nextArg = args[i + 1];\n\n\t\tconst {\n\t\t\tdata,\n\t\t\tname,\n\t\t\toption,\n\t\t\tskipNext,\n\t\t\tisHelp,\n\t\t\tisVersion,\n\t\t} = parseArg(nonPositionalEntries, positionalEntries, arg, nextArg);\n\t\tif (!option) unrecognizedArgsArr.push(arg.split('=')[0]!);\n\t\tif (skipNext) ++i;\n\n\t\tresult[name!] = data;\n\n\t\tif (isHelp) return 'help';\n\t\tif (isVersion) return 'version';\n\t}\n\n\tfor (const [optKey, option] of optEntries) {\n\t\tconst data = result[optKey] ?? option.default;\n\n\t\tif (!omitKeysOfUndefinedOptions) {\n\t\t\tresult[optKey] = data;\n\t\t} else {\n\t\t\tif (data !== undefined) result[optKey] = data;\n\t\t}\n\n\t\tif (option.isRequired && result[optKey] === undefined) missingRequiredArr.push([option.name!, ...option.aliases]);\n\t}\n\n\tif (missingRequiredArr.length) throw missingRequired(command, missingRequiredArr as [string[], ...string[][]]);\n\tif (unrecognizedArgsArr.length) throw unrecognizedOptions(command, unrecognizedArgsArr as [string, ...string[]]);\n\n\treturn result;\n};\n\nconst executeOrLog = async (target: string | Function | undefined) => {\n\tif (!target || typeof target === 'string') console.log(target);\n\telse await target();\n};\n\nexport const getCommandNameRecursive = (command: Command): string =>\n\tcommand.parent ? `${getCommandNameRecursive(command.parent)} ${command.name}` : command.name;\n\nconst validateCommands = (commands: Command[], parent?: Command) => {\n\tconst storedNames: Record<string, [string, ...string[]]> = {};\n\n\tfor (const cmd of commands) {\n\t\tconst storageVals = Object.values(storedNames);\n\n\t\tfor (const storage of storageVals) {\n\t\t\tconst nameOccupier = storage.find((e) => e === cmd.name);\n\n\t\t\tif (!nameOccupier) continue;\n\n\t\t\tthrow new Error(\n\t\t\t\t`Can't define command '${getCommandNameRecursive(cmd)}': name is already in use by command '${\n\t\t\t\t\tparent ? `${getCommandNameRecursive(parent)} ` : ''\n\t\t\t\t}${storage[0]}'!`,\n\t\t\t);\n\t\t}\n\n\t\tif (cmd.aliases) {\n\t\t\tfor (const alias of cmd.aliases) {\n\t\t\t\tfor (const storage of storageVals) {\n\t\t\t\t\tconst nameOccupier = storage.find((e) => e === alias);\n\n\t\t\t\t\tif (!nameOccupier) continue;\n\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Can't define command '${getCommandNameRecursive(cmd)}': alias '${alias}' is already in use by command '${\n\t\t\t\t\t\t\tparent ? `${getCommandNameRecursive(parent)} ` : ''\n\t\t\t\t\t\t}${storage[0]}'!`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstoredNames[cmd.name] = cmd.aliases\n\t\t\t? [cmd.name, ...cmd.aliases]\n\t\t\t: [cmd.name];\n\n\t\tif (cmd.subcommands) cmd.subcommands = validateCommands(cmd.subcommands, cmd) as [Command, ...Command[]];\n\t}\n\n\treturn commands;\n};\n\nconst removeByIndex = <T>(arr: T[], idx: number): T[] => [...arr.slice(0, idx), ...arr.slice(idx + 1, arr.length)];\n\nconst help = async (command: Command | string | undefined, commands: Command[], helpHandler: HelpHandler) =>\n\ttypeof command === 'object'\n\t\t? command.help !== undefined\n\t\t\t? await executeOrLog(command.help)\n\t\t\t: await helpHandler(command)\n\t\t: await helpHandler(commands);\n\n/**\n * Separated for testing purposes\n */\nexport const rawCli = async (commands: Command[], config?: BroCliConfig) => {\n\tconst processedCmds = validateCommands(commands);\n\n\tconst argSource = config?.argSource ?? process.argv;\n\tconst version = config?.version;\n\tconst helpHandler = config?.help ?? defaultTheme;\n\tconst omitKeysOfUndefinedOptions = config?.omitKeysOfUndefinedOptions ?? false;\n\n\tlet args = argSource.slice(2, argSource.length);\n\tif (!args.length) return await helpHandler(processedCmds);\n\n\tconst helpIndex = args.findIndex((arg) => arg === '--help' || arg === '-h');\n\tif (\n\t\thelpIndex !== -1 && (helpIndex > 0\n\t\t\t? args[helpIndex - 1]?.startsWith('-') && !args[helpIndex - 1]!.includes('=') ? false : true\n\t\t\t: true)\n\t) {\n\t\tconst command = getCommand(processedCmds, args).command;\n\n\t\treturn help(command, processedCmds, helpHandler);\n\t}\n\n\tconst versionIndex = args.findIndex((arg) => arg === '--version' || arg === '-v');\n\tif (versionIndex !== -1 && (versionIndex > 0 ? args[versionIndex - 1]?.startsWith('-') ? false : true : true)) {\n\t\treturn await executeOrLog(version);\n\t}\n\n\tconst { command, args: newArgs } = getCommand(processedCmds, args);\n\tif (!command) return helpHandler(processedCmds);\n\n\tif (command === 'help') {\n\t\tconst { command: helpCommand } = getCommand(processedCmds, newArgs);\n\n\t\treturn help(helpCommand, processedCmds, helpHandler);\n\t}\n\n\tconst optionResult = parseOptions(command, newArgs, omitKeysOfUndefinedOptions);\n\n\tif (optionResult === 'help') return await help(command, commands, helpHandler);\n\tif (optionResult === 'version') return await executeOrLog(version);\n\n\tif (optionResult) {\n\t\tif (config?.hook) await config.hook('pre', command);\n\t\tawait command.handler(command.transform ? await command.transform(optionResult) : optionResult);\n\t\tif (config?.hook) await config.hook('post', command);\n\t}\n\treturn undefined;\n};\n\n/**\n * Runs CLI commands\n *\n * @param commands - command collection\n *\n * @param argSource - source of cli arguments, optionally passed as a parameter for testing purposes and compatibility with custom environments\n */\nexport const run = async (commands: Command[], config?: BroCliConfig) => {\n\ttry {\n\t\tawait rawCli(commands, config);\n\t} catch (e) {\n\t\tconsole.error(typeof e === 'object' && e !== null && 'message' in e ? e.message : e);\n\n\t\tprocess.exit(1);\n\t}\n};\n\nexport const handler = <TOpts extends Record<string, GenericBuilderInternals>>(\n\toptions: TOpts,\n\thandler: CommandHandler<TOpts>,\n) => handler;\n\nconst shellArgs = (str: string) => {\n\tconst spaces: string[] = str.match(/\"[^\"]+\"|'[^']+'|\\S+/g) ?? [];\n\n\treturn spaces.flatMap((s) => parseQuotes(s)).map((s) => s.toString());\n};\n\nexport const test = async <TOpts, THandlerInput>(\n\tcommand: Command<TOpts, THandlerInput>,\n\targs: string,\n): Promise<TestResult<THandlerInput>> => {\n\ttry {\n\t\tconst cliParsedArgs: string[] = shellArgs(args);\n\t\tconst options = parseOptions(command, cliParsedArgs);\n\n\t\tif (options === 'help' || options === 'version') {\n\t\t\treturn {\n\t\t\t\ttype: options,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\toptions: command.transform ? await command.transform(options) : options,\n\t\t\ttype: 'handler',\n\t\t};\n\t} catch (e) {\n\t\treturn {\n\t\t\ttype: 'error',\n\t\t\terror: e,\n\t\t};\n\t}\n};\n\nexport const commandsInfo = (\n\tcommands: Command[],\n): CommandsInfo => {\n\tconst validated = validateCommands(commands);\n\n\treturn Object.fromEntries(validated.map((c) => [c.name, {\n\t\tname: c.name,\n\t\taliases: c.aliases,\n\t\tdescription: c.description,\n\t\tisHidden: c.hidden,\n\t\toptions: c.options\n\t\t\t? Object.fromEntries(Object.entries(c.options).map(([key, opt]) => [key, opt.config]))\n\t\t\t: undefined,\n\t\tmetaInfo: c.metaInfo,\n\t\tsubcommands: c.subcommands ? commandsInfo(c.subcommands) : undefined,\n\t}]));\n};\n","import type { Command, HelpHandler } from './command-core';\nimport type { ProcessedOptions } from './option-builder';\n\nexport const defaultTheme: HelpHandler = (calledFor) => {\n\tif (Array.isArray(calledFor)) {\n\t\tconst cmds = calledFor.filter((cmd) => !cmd.hidden);\n\n\t\tconst tableCmds = cmds.map((cmd) => ({\n\t\t\tname: cmd.name,\n\t\t\taliases: cmd.aliases ? cmd.aliases.join(', ') : '-',\n\t\t\tdescription: cmd.description ?? '-',\n\t\t}));\n\n\t\tconsole.log(`Here's the list of all available commands:`);\n\t\tconsole.table(tableCmds);\n\t\tconsole.log(\n\t\t\t'To read the details about any particular command type: [commandName] --help',\n\t\t);\n\t} else {\n\t\tconst options = calledFor.options\n\t\t\t? Object.values(calledFor.options).filter((opt) => !opt.config?.isHidden).map(\n\t\t\t\t({ config: opt }) => ({\n\t\t\t\t\tname: opt.name,\n\t\t\t\t\taliases: opt.aliases.length ? `${opt.aliases.join(', ')}` : '-',\n\t\t\t\t\tdescription: opt.description ?? '-',\n\t\t\t\t\ttype: opt.type,\n\t\t\t\t\trequired: opt.isRequired ? '✓' : '✗',\n\t\t\t\t}),\n\t\t\t)\n\t\t\t: undefined;\n\n\t\tconsole.log(\n\t\t\t`Command: ${calledFor.name}${calledFor.aliases ? ` [${calledFor.aliases.join(', ')}]` : ''}${\n\t\t\t\tcalledFor.description ? ` - ${calledFor.description}` : ''\n\t\t\t}`,\n\t\t);\n\n\t\tif (!options?.length) return;\n\n\t\tconsole.log('\\nOptions:');\n\t\tconsole.table(options);\n\t}\n};\n\n// Root help\nconst rootHelp = (commands: Command[]) => {\n};\n\n// Command help\nconst prepareCommandString = (command: Command) => {\n\tconst nameString = command.aliases ? `[${[command.name, ...command.aliases].join(' | ')}]` : command.name;\n\n\tconst optEntries = Object.entries(command.options ?? {} as Exclude<typeof command.options, undefined>);\n\n\tconst positionals = optEntries.filter(\n\t\t(opt) => !opt[1].config.isHidden && opt[1].config.type === 'positional',\n\t).map((p) => p[1].config.isRequired ? `[${p[1].config.name}]` : `<${p[1].config.name}>`);\n\n\tconst hasOpts = (optEntries.length - positionals.length) > 0;\n\n\tconst posString = positionals.join(' ');\n\n\tconst optionsString = hasOpts ? `[options]` : '';\n\n\treturn ['Usage:', [nameString, posString, optionsString].filter((s) => s.length).join(' ')].filter((e) => e !== '')\n\t\t.join('\\n');\n};\n\nconst padToLength = (input: string, length: number) => {\n\tconst output = input.length < length ? (input + ' '.repeat(length - input.length)) : input;\n\n\treturn output;\n};\n\nconst lineBreak = /(\\r)?\\n/g;\n\nconst splitByMaxLen = (input: string, length: number) => {\n\tif (input.length <= length) return input.split(lineBreak).map((i) => padToLength(i, length));\n\n\tlet output: string[] = [];\n\n\tfor (let line of input.split(lineBreak)) {\n\t\tdo {\n\t\t\tif (line.length <= length) {\n\t\t\t\toutput.push(padToLength(line, length));\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet nearSpace = -1;\n\n\t\t\tlet i = line.length - 1;\n\t\t\tdo {\n\t\t\t\tif (line[i] != ' ') continue;\n\n\t\t\t\tnearSpace = i;\n\t\t\t\tbreak;\n\t\t\t} while (i-- > 0);\n\n\t\t\tconst splitMark = nearSpace == -1 ? length - 1 : ++nearSpace;\n\t\t\tconst cLine = line.slice(0, splitMark + 1);\n\t\t\tconst rem = line.slice(splitMark + 1, line.length);\n\n\t\t\tline = rem;\n\n\t\t\toutput.push(padToLength(cLine, length));\n\t\t} while (line.length);\n\t}\n\n\treturn output;\n};\n\nconst prepareOptionStrings = (options: ProcessedOptions) => {\n\tconst opts = Object.entries(options)\n\t\t.filter((opt) => !opt[1].config.isHidden && opt[1].config.type !== 'positional').map((opt) => opt[1].config);\n\n\tif (!opts.length) return '';\n\n\tconst lengths = [2, 38, 30, 50];\n\tconst maxLen = lengths.reduce((p, e) => p + e, 0);\n\n\tconst strData = opts.map((opt) => {\n\t\tconst reqPrefix = opt.isRequired ? ' !' : '  ';\n\n\t\tconst rawAliases = opt.aliases.join(', ');\n\n\t\tconst aliases = rawAliases.length ? `${rawAliases},` : '';\n\n\t\tconst enumPart = opt.enumVals\n\t\t\t? `[ ${opt.enumVals.join(' | ')} ]`\n\t\t\t: opt.minVal !== undefined || opt.maxVal !== undefined\n\t\t\t? `${opt.minVal !== undefined ? `[ ${opt.minVal}` : '( ∞'} ; ${opt.maxVal !== undefined ? opt.maxVal : '∞ )'} ]`\n\t\t\t: '';\n\n\t\tconst namePart = enumPart ? `${opt.name} ${enumPart}` : opt.name;\n\n\t\tconst description = `${opt.description ? `${opt.description}` : ''}${\n\t\t\topt.description !== undefined && opt.default !== undefined ? ' ' : ''\n\t\t}${opt.default !== undefined ? `(default: ${opt.default})` : ''}`;\n\n\t\tconst data = [reqPrefix, aliases, namePart, description];\n\t\treturn data.map((str, i) => splitByMaxLen(str, lengths[i]!));\n\t});\n\n\tfor (let outerIdx = 0; outerIdx < strData.length; ++outerIdx) {\n\t\tconst cData = strData[outerIdx]!;\n\t\tconst rowMax = cData.reduce((p, e) => e.length > p ? e.length : p, 0);\n\n\t\tcData.forEach((d, i) => {\n\t\t\tif (d.length >= rowMax) return;\n\n\t\t\tdo {\n\t\t\t\td.push(padToLength('', lengths[i]!));\n\t\t\t} while (d.length < maxLen);\n\t\t});\n\t}\n\n\tconst lines: string[] = [];\n\n\tconst lineCnt = (strData[0]?.length ?? -1) + 1;\n\tconst iterations = lineCnt * strData.length;\n\n\tlet dataIdx = 0;\n\tlet lineIdx = 0;\n\tlet iterCount = 0;\n\n\tlet line = '';\n\n\twhile (iterCount++ < iterations) {\n\t\tif (lineIdx != 0 || lineIdx !== lineCnt) {\n\t\t\tline = line + ' ';\n\t\t}\n\n\t\tline = line + strData[dataIdx]![dataIdx]!;\n\n\t\tif (lineIdx == lineCnt) {\n\t\t\t++dataIdx;\n\t\t\tlineIdx = 0;\n\t\t\tlines.push(line);\n\t\t} else {\n\t\t\t++lineIdx;\n\t\t}\n\t}\n\n\treturn `Options:\\n${lines.join('\\n')}`;\n};\n\nconst commandHelp = (command: Command) => {\n\tconst cmd = prepareCommandString(command);\n\tconst options = command.options ? prepareOptionStrings(command.options) : '';\n\n\tconst toLog = [command.description, cmd, options].filter((e) => e !== '').join('\\n\\n');\n\n\tconsole.log(toLog);\n};\n\n// Theme core\nexport const defaultThemeWIP: HelpHandler = (calledFor) => {\n\tif (Array.isArray(calledFor)) {\n\t\trootHelp(calledFor);\n\t} else {\n\t\tcommandHelp(calledFor);\n\t}\n};\n","export function isInt(value: number) {\n\treturn value === Math.floor(value);\n}\n","import { BroCliError } from './brocli-error';\n\nexport type OptionType = 'string' | 'boolean' | 'number' | 'positional';\n\nexport type OutputType = string | boolean | number | undefined;\n\nexport type BuilderConfig<TType extends OptionType = OptionType> = {\n\tname?: string | undefined;\n\taliases: string[];\n\ttype: TType;\n\tdescription?: string;\n\tdefault?: OutputType;\n\tisHidden?: boolean;\n\tisRequired?: boolean;\n\tisInt?: boolean;\n\tminVal?: number;\n\tmaxVal?: number;\n\tenumVals?: [string, ...string[]];\n};\n\nexport type ProcessedBuilderConfig = {\n\tname: string;\n\taliases: string[];\n\ttype: OptionType;\n\tdescription?: string;\n\tdefault?: OutputType;\n\tisHidden?: boolean;\n\tisRequired?: boolean;\n\tisInt?: boolean;\n\tminVal?: number;\n\tmaxVal?: number;\n\tenumVals?: [string, ...string[]];\n};\n\nexport type BuilderConfigLimited = BuilderConfig & {\n\ttype: Exclude<OptionType, 'positional'>;\n};\n\nexport class OptionBuilderBase<\n\tTBuilderConfig extends BuilderConfig = BuilderConfig,\n\tTOutput extends OutputType = string,\n\tTOmit extends string = '',\n\tTEnums extends string | undefined = undefined,\n> {\n\tpublic _: {\n\t\tconfig: TBuilderConfig;\n\t\t/**\n\t\t * Type-level only field\n\t\t *\n\t\t * Do not attempt to access at a runtime\n\t\t */\n\t\t$output: TOutput;\n\t};\n\n\tprivate config = (): TBuilderConfig => this._.config;\n\n\tconstructor(config?: TBuilderConfig) {\n\t\tthis._ = {\n\t\t\tconfig: config ?? {\n\t\t\t\taliases: [],\n\t\t\t\ttype: 'string',\n\t\t\t} as unknown as TBuilderConfig,\n\t\t\t$output: undefined as any as TOutput,\n\t\t};\n\t}\n\n\tpublic string<TName extends string>(name: TName): Omit<\n\t\tOptionBuilderBase<\n\t\t\tBuilderConfig<'string'>,\n\t\t\tstring | undefined,\n\t\t\tTOmit | OptionType | 'min' | 'max' | 'int'\n\t\t>,\n\t\tTOmit | OptionType | 'min' | 'max' | 'int'\n\t>;\n\tpublic string(): Omit<\n\t\tOptionBuilderBase<\n\t\t\tBuilderConfig<'string'>,\n\t\t\tstring | undefined,\n\t\t\tTOmit | OptionType | 'min' | 'max' | 'int'\n\t\t>,\n\t\tTOmit | OptionType | 'min' | 'max' | 'int'\n\t>;\n\tpublic string(\n\t\tname?: string,\n\t) {\n\t\tconst config = this.config();\n\n\t\treturn new OptionBuilderBase({ ...config, type: 'string', name: name }) as any;\n\t}\n\n\tpublic number<TName extends string>(name: TName): Omit<\n\t\tOptionBuilderBase<\n\t\t\tBuilderConfig<'number'>,\n\t\t\tnumber | undefined,\n\t\t\tTOmit | OptionType | 'enum'\n\t\t>,\n\t\tTOmit | OptionType | 'enum'\n\t>;\n\tpublic number(): Omit<\n\t\tOptionBuilderBase<\n\t\t\tBuilderConfig<'number'>,\n\t\t\tstring | undefined,\n\t\t\tTOmit | OptionType | 'enum'\n\t\t>,\n\t\tTOmit | OptionType | 'enum'\n\t>;\n\tpublic number(\n\t\tname?: string,\n\t) {\n\t\tconst config = this.config();\n\n\t\treturn new OptionBuilderBase({ ...config, type: 'number', name: name }) as any;\n\t}\n\n\tpublic boolean<TName extends string>(name: TName): Omit<\n\t\tOptionBuilderBase<\n\t\t\tBuilderConfig<'boolean'>,\n\t\t\tboolean | undefined,\n\t\t\tTOmit | OptionType | 'min' | 'max' | 'enum' | 'int'\n\t\t>,\n\t\tTOmit | OptionType | 'min' | 'max' | 'enum' | 'int'\n\t>;\n\tpublic boolean(): Omit<\n\t\tOptionBuilderBase<\n\t\t\tBuilderConfig<'boolean'>,\n\t\t\tboolean | undefined,\n\t\t\tTOmit | OptionType | 'min' | 'max' | 'enum' | 'int'\n\t\t>,\n\t\tTOmit | OptionType | 'min' | 'max' | 'enum' | 'int'\n\t>;\n\tpublic boolean(\n\t\tname?: string,\n\t) {\n\t\tconst config = this.config();\n\n\t\treturn new OptionBuilderBase({ ...config, type: 'boolean', name: name }) as any;\n\t}\n\n\tpublic positional<TName extends string>(displayName: TName): Omit<\n\t\tOptionBuilderBase<\n\t\t\tBuilderConfig<'positional'>,\n\t\t\tstring | undefined,\n\t\t\tTOmit | OptionType | 'min' | 'max' | 'int' | 'alias'\n\t\t>,\n\t\tTOmit | OptionType | 'min' | 'max' | 'int' | 'alias'\n\t>;\n\tpublic positional(): Omit<\n\t\tOptionBuilderBase<\n\t\t\tBuilderConfig<'positional'>,\n\t\t\tstring | undefined,\n\t\t\tTOmit | OptionType | 'min' | 'max' | 'int' | 'alias'\n\t\t>,\n\t\tTOmit | OptionType | 'min' | 'max' | 'int' | 'alias'\n\t>;\n\tpublic positional(displayName?: string) {\n\t\tconst config = this.config();\n\n\t\treturn new OptionBuilderBase({ ...config, type: 'positional', name: displayName }) as any;\n\t}\n\n\tpublic alias(\n\t\t...aliases: string[]\n\t): Omit<\n\t\tOptionBuilderBase<\n\t\t\tTBuilderConfig,\n\t\t\tTOutput,\n\t\t\tTOmit | 'alias'\n\t\t>,\n\t\tTOmit | 'alias'\n\t> {\n\t\tconst config = this.config();\n\n\t\treturn new OptionBuilderBase({ ...config, aliases }) as any;\n\t}\n\n\tpublic desc<TDescription extends string>(description: TDescription): Omit<\n\t\tOptionBuilderBase<\n\t\t\tTBuilderConfig,\n\t\t\tTOutput,\n\t\t\tTOmit | 'desc'\n\t\t>,\n\t\tTOmit | 'desc'\n\t> {\n\t\tconst config = this.config();\n\n\t\treturn new OptionBuilderBase({ ...config, description }) as any;\n\t}\n\n\tpublic hidden(): Omit<\n\t\tOptionBuilderBase<\n\t\t\tTBuilderConfig,\n\t\t\tTOutput,\n\t\t\tTOmit | 'hidden'\n\t\t>,\n\t\tTOmit | 'hidden'\n\t> {\n\t\tconst config = this.config();\n\n\t\treturn new OptionBuilderBase({ ...config, isHidden: true }) as any;\n\t}\n\n\tpublic required(): Omit<\n\t\tOptionBuilderBase<\n\t\t\tTBuilderConfig,\n\t\t\tExclude<TOutput, undefined>,\n\t\t\tTOmit | 'required' | 'default'\n\t\t>,\n\t\tTOmit | 'required' | 'default'\n\t> {\n\t\tconst config = this.config();\n\n\t\treturn new OptionBuilderBase({ ...config, isRequired: true }) as any;\n\t}\n\n\tpublic default<TDefVal extends TEnums extends undefined ? Exclude<TOutput, undefined> : TEnums>(value: TDefVal): Omit<\n\t\tOptionBuilderBase<\n\t\t\tTBuilderConfig,\n\t\t\tExclude<TOutput, undefined>,\n\t\t\tTOmit | 'enum' | 'required' | 'default',\n\t\t\tTEnums\n\t\t>,\n\t\tTOmit | 'enum' | 'required' | 'default'\n\t> {\n\t\tconst config = this.config();\n\n\t\tconst enums = config.enumVals;\n\t\tif (enums && !enums.find((v) => value === v)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Option enums [ ${enums.join(', ')} ] are incompatible with default value ${value}`,\n\t\t\t);\n\t\t}\n\n\t\treturn new OptionBuilderBase({ ...config, default: value }) as any;\n\t}\n\n\tpublic enum<TValues extends [string, ...string[]]>(...values: TValues): Omit<\n\t\tOptionBuilderBase<\n\t\t\tTBuilderConfig,\n\t\t\tTValues[number],\n\t\t\tTOmit | 'enum',\n\t\t\tTValues[number]\n\t\t>,\n\t\tTOmit | 'enum'\n\t> {\n\t\tconst config = this.config();\n\n\t\tconst defaultVal = config.default;\n\t\tif (defaultVal !== undefined && !values.find((v) => defaultVal === v)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Option enums [ ${values.join(', ')} ] are incompatible with default value ${defaultVal}`,\n\t\t\t);\n\t\t}\n\n\t\treturn new OptionBuilderBase({ ...config, enumVals: values }) as any;\n\t}\n\n\tpublic min(value: number): Omit<\n\t\tOptionBuilderBase<\n\t\t\tTBuilderConfig,\n\t\t\tTOutput,\n\t\t\tTOmit | 'min'\n\t\t>,\n\t\tTOmit | 'min'\n\t> {\n\t\tconst config = this.config();\n\n\t\tconst maxVal = config.maxVal;\n\t\tif (maxVal !== undefined && maxVal < value) {\n\t\t\tthrow new BroCliError(\"Unable to define option's min value to be higher than max value!\");\n\t\t}\n\n\t\treturn new OptionBuilderBase({ ...config, minVal: value }) as any;\n\t}\n\n\tpublic max(value: number): Omit<\n\t\tOptionBuilderBase<\n\t\t\tTBuilderConfig,\n\t\t\tTOutput,\n\t\t\tTOmit | 'max'\n\t\t>,\n\t\tTOmit | 'max'\n\t> {\n\t\tconst config = this.config();\n\n\t\tconst minVal = config.minVal;\n\t\tif (minVal !== undefined && minVal < value) {\n\t\t\tthrow new BroCliError(\"Unable to define option's max value to be lower than min value!\");\n\t\t}\n\n\t\treturn new OptionBuilderBase({ ...config, maxVal: value }) as any;\n\t}\n\n\tpublic int(): Omit<\n\t\tOptionBuilderBase<\n\t\t\tTBuilderConfig,\n\t\t\tTOutput,\n\t\t\tTOmit | 'int'\n\t\t>,\n\t\tTOmit | 'int'\n\t> {\n\t\tconst config = this.config();\n\n\t\treturn new OptionBuilderBase({ ...config, isInt: true }) as any;\n\t}\n}\n\nexport type GenericBuilderInternalsFields = {\n\t/**\n\t * Type-level only field\n\t *\n\t * Do not attempt to access at a runtime\n\t */\n\t$output: OutputType;\n\tconfig: BuilderConfig;\n};\n\nexport type GenericBuilderInternals = {\n\t_: GenericBuilderInternalsFields;\n};\n\nexport type GenericBuilderInternalsFieldsLimited = {\n\t/**\n\t * Type-level only field\n\t *\n\t * Do not attempt to access at a runtime\n\t */\n\t$output: OutputType;\n\tconfig: BuilderConfigLimited;\n};\n\nexport type GenericBuilderInternalsLimited = {\n\t_: GenericBuilderInternalsFieldsLimited;\n};\n\nexport type ProcessedOptions<\n\tTOptionConfig extends Record<string, GenericBuilderInternals> = Record<string, GenericBuilderInternals>,\n> = {\n\t[K in keyof TOptionConfig]: K extends string ? {\n\t\t\tconfig: ProcessedBuilderConfig;\n\t\t\t/**\n\t\t\t * Type-level only field\n\t\t\t *\n\t\t\t * Do not attempt to access at a runtime\n\t\t\t */\n\t\t\t$output: TOptionConfig[K]['_']['$output'];\n\t\t}\n\t\t: never;\n};\n\nexport type Simplify<T> =\n\t& {\n\t\t[K in keyof T]: T[K];\n\t}\n\t& {};\n\nexport type TypeOf<TOptions extends Record<string, GenericBuilderInternals>> = Simplify<\n\t{\n\t\t[K in keyof TOptions]: TOptions[K]['_']['$output'];\n\t}\n>;\n\nexport function string<TName extends string>(\n\tname: TName,\n): Omit<\n\tOptionBuilderBase<\n\t\tBuilderConfig<'string'>,\n\t\tstring | undefined,\n\t\tOptionType | 'min' | 'max' | 'int'\n\t>,\n\tOptionType | 'min' | 'max' | 'int'\n>;\nexport function string(): Omit<\n\tOptionBuilderBase<\n\t\tBuilderConfig<'string'>,\n\t\tstring | undefined,\n\t\tOptionType | 'min' | 'max' | 'int'\n\t>,\n\tOptionType | 'min' | 'max' | 'int'\n>;\nexport function string<TName extends string>(name?: TName) {\n\treturn typeof name === 'string' ? new OptionBuilderBase().string(name) : new OptionBuilderBase().string();\n}\n\nexport function number<TName extends string>(\n\tname: TName,\n): Omit<\n\tOptionBuilderBase<\n\t\tBuilderConfig<'number'>,\n\t\tnumber | undefined,\n\t\tOptionType | 'enum'\n\t>,\n\tOptionType | 'enum'\n>;\nexport function number(): Omit<\n\tOptionBuilderBase<\n\t\tBuilderConfig<'number'>,\n\t\tnumber | undefined,\n\t\tOptionType | 'enum'\n\t>,\n\tOptionType | 'enum'\n>;\nexport function number<TName extends string>(name?: TName) {\n\treturn typeof name === 'string' ? new OptionBuilderBase().number(name) : new OptionBuilderBase().number();\n}\n\nexport function boolean<TName extends string>(\n\tname: TName,\n): Omit<\n\tOptionBuilderBase<\n\t\tBuilderConfig<'boolean'>,\n\t\tboolean | undefined,\n\t\tOptionType | 'min' | 'max' | 'int' | 'enum'\n\t>,\n\tOptionType | 'min' | 'max' | 'int' | 'enum'\n>;\nexport function boolean(): Omit<\n\tOptionBuilderBase<\n\t\tBuilderConfig<'boolean'>,\n\t\tboolean | undefined,\n\t\tOptionType | 'min' | 'max' | 'int' | 'enum'\n\t>,\n\tOptionType | 'min' | 'max' | 'int' | 'enum'\n>;\nexport function boolean<TName extends string>(name?: TName) {\n\treturn typeof name === 'string' ? new OptionBuilderBase().boolean(name) : new OptionBuilderBase().boolean();\n}\n\nexport function positional<TName extends string>(displayName: TName): Omit<\n\tOptionBuilderBase<\n\t\tBuilderConfig<'positional'>,\n\t\tstring | undefined,\n\t\tOptionType | 'min' | 'max' | 'int' | 'alias'\n\t>,\n\tOptionType | 'min' | 'max' | 'int' | 'alias'\n>;\nexport function positional(): Omit<\n\tOptionBuilderBase<\n\t\tBuilderConfig<'positional'>,\n\t\tstring | undefined,\n\t\tOptionType | 'min' | 'max' | 'int' | 'alias'\n\t>,\n\tOptionType | 'min' | 'max' | 'int' | 'alias'\n>;\nexport function positional(displayName?: string) {\n\treturn typeof displayName === 'string'\n\t\t? new OptionBuilderBase().positional(displayName)\n\t\t: new OptionBuilderBase().positional();\n}\n"],"mappings":"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","names":["clone","parent","depth","string","i","s","command","clone","handler","parseQuotes"]}